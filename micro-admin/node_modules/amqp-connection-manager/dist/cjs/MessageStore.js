"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryMessageStore = void 0;
class InMemoryMessageStore {
    constructor() {
        /** Queued messages, not yet sent. */
        this._messages = [];
        /** Published, but not yet confirmed messages. */
        this._unconfirmedMessages = [];
    }
    queueMessage(message, timeout) {
        if (timeout) {
            message.timeout = setTimeout(() => {
                let idx = this._messages.indexOf(message);
                if (idx !== -1) {
                    this._messages.splice(idx, 1);
                }
                else {
                    idx = this._unconfirmedMessages.indexOf(message);
                    if (idx !== -1) {
                        this._unconfirmedMessages.splice(idx, 1);
                    }
                }
                message.isTimedout = true;
                message.reject(new Error('timeout'));
            }, timeout);
        }
        this._messages.push(message);
    }
    getMessageToSend() {
        return this._messages.shift();
    }
    queueLength() {
        return this._messages.length;
    }
    messageSent(message) {
        this._unconfirmedMessages.push(message);
    }
    messageSendFailed(message) {
        this._removeUnconfirmedMessage(message);
        // Tried to write to a closed channel.  Put the message back in the queue
        // and we'll try again when we reconnect.
        // TODO: Are we worried about re-ordering messages here?
        this._messages.unshift(message);
    }
    messageResolved(message, canSend) {
        this._removeUnconfirmedMessage(message);
        message.resolve(canSend);
    }
    messageRejected(message, err) {
        this._removeUnconfirmedMessage(message);
        message.reject(err);
    }
    rejectAll(err) {
        if (this._messages.length !== 0) {
            // Reject any unsent messages.
            this._messages.forEach((message) => {
                if (message.timeout) {
                    clearTimeout(message.timeout);
                }
                message.reject(err);
            });
        }
        if (this._unconfirmedMessages.length !== 0) {
            // Reject any unconfirmed messages.
            this._unconfirmedMessages.forEach((message) => {
                if (message.timeout) {
                    clearTimeout(message.timeout);
                }
                message.reject(err);
            });
        }
    }
    _removeUnconfirmedMessage(message) {
        const toRemove = this._unconfirmedMessages.indexOf(message);
        if (toRemove === -1) {
            throw new Error(`Message is not in _unconfirmedMessages!`);
        }
        const removed = this._unconfirmedMessages.splice(toRemove, 1);
        return removed[0];
    }
}
exports.InMemoryMessageStore = InMemoryMessageStore;
